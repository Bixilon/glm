package de.bixilon.kotlinglm.gtx

import io.kotest.core.spec.style.StringSpec

class testGtxRandom : StringSpec() {

    init {

//        "signedRand1" { TODO
//
//            var resultFloat = 0f
//            var resultDouble = 0.0
//            for(i in 0 .. 9999)
//            {
//                resultFloat += GLM.signedRand1<float>()
//                resultDouble += glm::signedRand1<double>()
//            }
//
//            Error += glm::equalEpsilon(ResultFloat, 0.0f, 0.0001f)
//            Error += glm::equalEpsilon(ResultDouble, 0.0, 0.0001)
//        }
//
//        int test_normalizedRand2()
//        {
//            int Error = 0;
//
//            {
//                std::size_t Max = 100000;
//                float ResultFloat = 0.0f;
//                double ResultDouble = 0.0f;
//                for(std::size_t i = 0; i < Max; ++i)
//                {
//                    ResultFloat += glm::length(GLM::normalizedRand2<float>());
//                    ResultDouble += glm::length(GLM::normalizedRand2<double>());
//                }
//
//                Error += glm::equalEpsilon(ResultFloat, float(Max), 0.000001f) ? 0 : 1;
//                Error += glm::equalEpsilon(ResultDouble, double(Max), 0.000001) ? 0 : 1;
//                assert(!Error);
//            }
//
//            return Error;
//        }
//
//        int test_normalizedRand3()
//        {
//            int Error = 0;
//
//            {
//                std::size_t Max = 100000;
//                float ResultFloatA = 0.0f;
//                float ResultFloatB = 0.0f;
//                float ResultFloatC = 0.0f;
//                double ResultDoubleA = 0.0f;
//                double ResultDoubleB = 0.0f;
//                double ResultDoubleC = 0.0f;
//                for(std::size_t i = 0; i < Max; ++i)
//                {
//                    ResultFloatA += glm::length(GLM::normalizedRand3<float>());
//                    ResultDoubleA += glm::length(GLM::normalizedRand3<double>());
//                    ResultFloatB += glm::length(GLM::normalizedRand3(2.0f, 2.0f));
//                    ResultDoubleB += glm::length(GLM::normalizedRand3(2.0, 2.0));
//                    ResultFloatC += glm::length(GLM::normalizedRand3(1.0f, 3.0f));
//                    ResultDoubleC += glm::length(GLM::normalizedRand3(1.0, 3.0));
//                }
//
//                Error += glm::equalEpsilon(ResultFloatA, float(Max), 0.0001f) ? 0 : 1;
//                Error += glm::equalEpsilon(ResultDoubleA, double(Max), 0.0001) ? 0 : 1;
//                Error += glm::equalEpsilon(ResultFloatB, float(Max * 2), 0.0001f) ? 0 : 1;
//                Error += glm::equalEpsilon(ResultDoubleB, double(Max * 2), 0.0001) ? 0 : 1;
//                Error += (ResultFloatC >= float(Max) && ResultFloatC <= float(Max * 3)) ? 0 : 1;
//                Error += (ResultDoubleC >= double(Max) && ResultDoubleC <= double(Max * 3)) ? 0 : 1;
//            }
//
//            return Error;
//        }
    }
}
